<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ArcadeKit — 2D Editor</title>
<style>
  :root { --bg:#0f1020; --ink:#e8e9ff; --muted:#a3a9bd; --panel:rgba(22,24,42,.55); --accent:#7c93ff; }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:#0f1020;color:var(--ink);font:500 14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif}
  canvas{display:block;width:100vw;height:100vh;background:#0d0f1d;image-rendering:pixelated;cursor:crosshair}
  .ui{
    position:fixed;inset:12px auto auto 12px;width:380px;max-height:calc(100dvh - 24px);
    display:grid;gap:10px;padding:12px;border-radius:14px;background:var(--panel);backdrop-filter:blur(10px);
    border:1px solid rgba(124,147,255,.25);box-shadow:0 20px 50px rgba(0,0,0,.35);overflow:auto
  }
  h1{margin:0 0 6px;font-size:15px;color:var(--accent);letter-spacing:.3px;display:flex;align-items:center;justify-content:space-between;gap:8px}
  .row{display:grid;gap:8px}
  .btn,.chip,.seg button{border:1px solid rgba(255,255,255,.12);background:#11152a;color:var(--ink);padding:8px 10px;border-radius:10px;cursor:pointer}
  .btn:hover,.chip:hover,.seg button:hover{background:#141936}
  .seg{display:flex;gap:6px;flex-wrap:wrap}
  .active{background:#1a2144;border-color:rgba(124,147,255,.45);color:var(--accent)}
  .kbd{background:rgba(255,255,255,.08);padding:2px 6px;border-radius:6px;border:1px solid rgba(255,255,255,.12)}
  .layers{display:grid;gap:6px}
  .layer{display:grid;grid-template-columns:auto 1fr auto;align-items:center;gap:8px;padding:6px 8px;border-radius:10px;background:#0f1430;border:1px solid rgba(255,255,255,.08)}
  .name{font-weight:600}
  .legend{display:flex;gap:8px;flex-wrap:wrap}
  .chip{display:flex;align-items:center;gap:8px}
  .swatch{width:14px;height:14px;border-radius:4px;border:1px solid rgba(255,255,255,.25)}
  .hint{color:var(--muted);font-size:12px}
  .badge{position:fixed;right:12px;bottom:10px;font-variant-numeric:tabular-nums;color:var(--muted);background:rgba(255,255,255,.05);padding:6px 10px;border-radius:8px;border:1px solid rgba(255,255,255,.1)}
  .hidden{display:none}
</style>
</head>
<body>
<canvas id="game"></canvas>

<div class="ui" id="panel">
  <div>
    <h1>
      ArcadeKit — 2D Editor
      <a class="btn" href="./home.html">Home</a>
    </h1>
    <div class="hint">
      Left-click paint • Right-click erase • <span class="kbd">Space</span>+drag pan •
      <span class="kbd">=</span>/<span class="kbd">-</span>/<span class="kbd">0</span> zoom • <span class="kbd">1–5</span> layer
    </div>
    <div class="hint">
      <b>Shift</b> paints <i>solid</i> only • <b>Ctrl</b> paints <i>type</i> only • <b>Alt+Click</b> eyedropper
    </div>
  </div>

  <div class="row">
    <div class="legend">
      <button class="chip active" id="tool-paint"><span class="swatch" style="background:linear-gradient(45deg,#232746 50%,#3b4274 0)"></span> Paint</button>
      <button class="chip" id="tool-erase"><span class="swatch" style="background:transparent"></span> Erase</button>
    </div>
  </div>

  <div class="row">
    <div class="legend" id="tilePalette"></div>
    <div class="seg">
      <button class="btn" id="solidBtn">Solid: Off (C)</button>
      <button class="btn" id="colliderVisBtn">Show Colliders: On (H)</button>
    </div>
  </div>

  <div class="row">
    <div class="layers" id="layerBtns"></div>
    <div class="hint">Layer 1 = bottom, Layer 5 = top.</div>
  </div>

  <div class="row" style="grid-template-columns:repeat(3,1fr)">
    <button class="btn" id="clearLayerBtn">Clear Layer</button>
    <button class="btn" id="clearAllBtn">Clear All</button>
    <button class="btn" id="toggleGridBtn">Grid</button>
  </div>

  <div class="row">
    <div class="seg" style="flex-wrap:wrap">
      <button class="btn" id="exportBtn">Export JSON</button>
      <button class="btn" id="copyBtn">Copy JSON</button>
      <button class="btn" id="importBtn">Import JSON</button>
      <button class="btn" id="saveSetBtn">Save to My Sets</button>
      <input class="hidden" type="file" id="fileInput" accept="application/json">
    </div>
    <div class="hint">Autosaves locally. Load templates via <code>?template=meadow|island|arena</code> or saved sets via <code>?setId=...</code>.</div>
  </div>

  <div class="row">
    <div class="seg">
      <button class="btn" id="playBtn">▶ Playtest</button>
      <span class="hint">WASD/Arrows • Shift to sprint • Smooth camera</span>
    </div>
  </div>
</div>

<div class="badge" id="badge">0 fps</div>

<script>
(() => {
  // ===== BASIC CONFIG =====
  const TILE = 48, MAP_W = 60, MAP_H = 34, LAYERS = 5;
  const VIEW = { zoom: 1.8, min: 0.9, max: 3.5, step: 0.1, def: 1.8 };
  const PLAYER = { radius: 14, baseSpeed: 170, sprintMult: 1.45, color: "#ffd86b" };

  // Visual types (collision is a separate flag)
  const TILES = { EMPTY:0, GRASS:1, WALL:2, DIRT:3, PATH:4, SAND:5, WATER:6, STONE:7 };
  const TILE_PALETTE = [
    { key:"GRASS", label:"Grass", color:"#2f7d3b" },
    { key:"DIRT",  label:"Dirt",  color:"#6b4a2b" },
    { key:"PATH",  label:"Path",  color:"#b99a66" },
    { key:"SAND",  label:"Sand",  color:"#d8c27a" },
    { key:"WATER", label:"Water", color:"#2d6bba" },
    { key:"STONE", label:"Stone", color:"#7a808c" },
    { key:"WALL",  label:"Wall (visual)", color:"#3b4274" }
  ];
  const COLORS = {
    grid:"rgba(255,255,255,0.06)", hover:"rgba(124,147,255,0.22)",
    wallTop:"#4a579a", wallFace:"#2a2f55", wallOutline:"#a9b1ff", wallEdge:"rgba(0,0,0,0.40)",
    solidStroke:"rgba(255,119,119,0.9)", solidFill:"rgba(255,80,80,0.12)"
  };

  // ===== CANVAS =====
  let DPR=1; const cvs=document.getElementById('game'); const ctx=cvs.getContext('2d');
  function resize(){ DPR=Math.max(1,Math.min(2,window.devicePixelRatio||1)); cvs.width=Math.floor(innerWidth*DPR); cvs.height=Math.floor(innerHeight*DPR); ctx.setTransform(DPR,0,0,DPR,0,0); }
  addEventListener('resize', resize, {passive:true}); resize();

  // ===== MAP: { t: type, s:0|1 } =====
  const makeTile=(t=TILES.EMPTY,s=0)=>({t,s});
  const make2D=(w,h,fn)=>Array.from({length:h},(_,y)=>Array.from({length:w},(_,x)=>fn(x,y)));
  const map={ layers:Array.from({length:LAYERS},()=>make2D(MAP_W,MAP_H,()=>makeTile())), meta:{w:MAP_W,h:MAP_H,tile:TILE,tiles:TILES,version:4} };
  const world={ w:MAP_W*TILE, h:MAP_H*TILE };

  // ===== CAMERA / PLAYER =====
  const camera={x:0,y:0,vx:0,vy:0}, CAM={smoothTime:0.14,maxSpeed:6000,lookAhead:38};
  const player={x:TILE*3,y:TILE*3,face:{x:1,y:0}};
  let playtest=false, showGrid=true, showSolidOverlay=true, currentLayer=1, tool='paint', tileKey='GRASS', brushSolid=false;

  const keys=new Set(); const mouse={down:false,button:0,panning:false,panStart:{x:0,y:0},camStart:{x:0,y:0},worldX:0,worldY:0,tx:-1,ty:-1};

  // ===== PATTERNS =====
  const patterns={};
  function makePattern(w,h,draw){ const c=document.createElement('canvas'); c.width=w;c.height=h; const k=c.getContext('2d'); draw(k,w,h); return k.createPattern(c,'repeat'); }
  function initPatterns(){
    patterns.GRASS = makePattern(16,16,(k,w,h)=>{ k.fillStyle="#244e2c";k.fillRect(0,0,w,h);k.fillStyle="#2e6a37";for(let y=0;y<h;y+=8){for(let x=0;x<w;x+=8){k.fillRect(x,y,8,8)}} k.strokeStyle="rgba(255,255,255,0.06)";k.lineWidth=1; for(let i=0;i<6;i++){const x=Math.random()*w,y=Math.random()*h;k.beginPath();k.moveTo(x,y);k.lineTo(x+1,y-2);k.stroke()} });
    patterns.DIRT  = makePattern(16,16,(k,w,h)=>{ k.fillStyle="#5f3f27";k.fillRect(0,0,w,h);k.fillStyle="#6b4a2b"; for(let i=0;i<18;i++){k.globalAlpha=.15+Math.random()*.25;k.beginPath();k.arc(Math.random()*w,Math.random()*h,Math.random()*1.5+.5,0,Math.PI*2);k.fill()} k.globalAlpha=1; });
    patterns.PATH  = makePattern(16,16,(k,w,h)=>{ k.fillStyle="#b99a66";k.fillRect(0,0,w,h);k.strokeStyle="rgba(0,0,0,0.10)";k.lineWidth=1; for(let i=-h;i<w+h;i+=5){k.beginPath();k.moveTo(i,0);k.lineTo(i-h,h);k.stroke()} });
    patterns.SAND  = makePattern(16,16,(k,w,h)=>{ k.fillStyle="#d8c27a";k.fillRect(0,0,w,h);k.fillStyle="rgba(0,0,0,0.10)";for(let i=0;i<20;i++){k.fillRect(Math.random()*w,Math.random()*h,1,1)} k.fillStyle="rgba(255,255,255,0.12)";for(let i=0;i<12;i++){k.fillRect(Math.random()*w,Math.random()*h,1,1)} });
    patterns.WATER = makePattern(32,32,(k,w,h)=>{ const g=k.createLinearGradient(0,0,0,h); g.addColorStop(0,"#1f4b85"); g.addColorStop(1,"#15365f"); k.fillStyle=g;k.fillRect(0,0,w,h); k.strokeStyle="rgba(255,255,255,0.15)";k.lineWidth=1; for(let y=4;y<h;y+=8){k.beginPath(); for(let x=0;x<=w;x+=4){k.lineTo(x,y+Math.sin((x+y)*.25)*1.2)} k.stroke()} });
    patterns.STONE = makePattern(16,16,(k,w,h)=>{ const g=k.createLinearGradient(0,0,0,h);g.addColorStop(0,"#757b86");g.addColorStop(1,"#666c77");k.fillStyle=g;k.fillRect(0,0,w,h);k.strokeStyle="rgba(0,0,0,0.22)";k.lineWidth=1;k.beginPath();k.moveTo(0,0);k.lineTo(w,0);k.moveTo(0,h);k.lineTo(w,h);k.moveTo(0,0);k.lineTo(0,h);k.moveTo(w,0);k.lineTo(w,h);k.stroke();k.fillStyle="rgba(255,255,255,0.08)";k.fillRect(4,8,1,1);k.fillStyle="rgba(0,0,0,0.15)";k.fillRect(12,6,1,1); });
  }
  initPatterns();

  // ===== UI HOOKS =====
  const $ = id=>document.getElementById(id);
  const toolPaint=$('tool-paint'), toolErase=$('tool-erase');
  function setTool(t){tool=t; toolPaint.classList.toggle('active',t==='paint'); toolErase.classList.toggle('active',t==='erase')}
  toolPaint.onclick=()=>setTool('paint'); toolErase.onclick=()=>setTool('erase'); setTool('paint');

  const tilePalette=$('tilePalette');
  function renderPalette(){ tilePalette.innerHTML=''; TILE_PALETTE.forEach(item=>{ const b=document.createElement('button'); b.className='chip'; b.dataset.tile=item.key; b.innerHTML=`<span class="swatch" style="background:${item.color}"></span>${item.label}`; if(item.key===tileKey) b.classList.add('active'); b.onclick=()=>{tileKey=item.key; [...tilePalette.children].forEach(c=>c.classList.remove('active')); b.classList.add('active')}; tilePalette.appendChild(b); }); }
  renderPalette();

  const solidBtn=$('solidBtn'), colliderVisBtn=$('colliderVisBtn');
  function refreshSolidBtn(){ solidBtn.textContent=`Solid: ${brushSolid?'On':'Off'} (C)`; solidBtn.classList.toggle('active',brushSolid) }
  function refreshColliderVisBtn(){ colliderVisBtn.textContent=`Show Colliders: ${showSolidOverlay?'On':'Off'} (H)`; colliderVisBtn.classList.toggle('active',showSolidOverlay) }
  solidBtn.onclick=()=>{brushSolid=!brushSolid;refreshSolidBtn()}; colliderVisBtn.onclick=()=>{showSolidOverlay=!showSolidOverlay;refreshColliderVisBtn()}; refreshSolidBtn(); refreshColliderVisBtn();

  const layerBtns=$('layerBtns'), layerUI=[];
  for(let i=1;i<=LAYERS;i++){ const row=document.createElement('div'); row.className='layer';
    const eye=document.createElement('input'); eye.type='checkbox'; eye.checked=true; eye.title='Toggle visibility';
    const name=document.createElement('div'); name.className='name'; name.textContent=`Layer ${i}${i===1?' (bottom)':''}${i===5?' (top)':''}`;
    const pick=document.createElement('button'); pick.className='btn'; pick.textContent='Select'; pick.onclick=()=>setLayer(i);
    eye.onchange=()=>{layerUI[i-1].visible=eye.checked}; row.append(eye,name,pick); layerBtns.appendChild(row); layerUI.push({visible:true,eye,pick});
  }
  function setLayer(n){ currentLayer=n; layerUI.forEach((L,idx)=>L.pick.classList.toggle('active',idx===n-1)) } setLayer(1);

  $('clearLayerBtn').onclick=()=>{ map.layers[currentLayer-1]=make2D(MAP_W,MAP_H,()=>makeTile()); saveAutosave() };
  $('clearAllBtn').onclick=()=>{ for(let i=0;i<LAYERS;i++) map.layers[i]=make2D(MAP_W,MAP_H,()=>makeTile()); saveAutosave() };
  $('toggleGridBtn').onclick=()=>{ showGrid=!showGrid };
  $('exportBtn').onclick=()=>download('map.json', JSON.stringify(map));
  $('copyBtn').onclick=async()=>{ try{ await navigator.clipboard.writeText(JSON.stringify(map)); alert('Copied JSON'); }catch{ alert('Clipboard blocked; use Export'); } };
  $('importBtn').onclick=()=>$('fileInput').click();
  $('fileInput').addEventListener('change', async (e)=>{
    const f=e.target.files[0]; if(!f) return;
    try{
      const t=await f.text(), o=JSON.parse(t);
      if(!o.layers||!o.meta) throw new Error('Invalid');
      if(o.meta.w!==MAP_W||o.meta.h!==MAP_H||o.meta.tile!==TILE) throw new Error('Size mismatch');
      if(o.meta.version>=4){
        for(let l=0;l<LAYERS;l++){ map.layers[l]=o.layers[l].map(r=>r.map(c=>makeTile(validType(c.t), c.s?1:0))) }
      } else {
        // legacy int maps: treat "2" as solid WALL
        const WALL=(o.meta.tiles&&o.meta.tiles.WALL)||2;
        for(let l=0;l<LAYERS;l++){ map.layers[l]=o.layers[l].map(r=>r.map(v=>{const t=Number(v)|0; return makeTile(Object.values(TILES).includes(t)?t:TILES.GRASS, t===WALL?1:0)})) }
      }
      saveAutosave(true);
    }catch(err){ alert('Import failed: '+err.message) } finally{ e.target.value='' }
  });

  // Save to My Sets (home.html)
  const LS_SETS='gk_sets_v1';
  function getSets(){ try{ return JSON.parse(localStorage.getItem(LS_SETS))||[] }catch{ return [] } }
  function saveSets(arr){ localStorage.setItem(LS_SETS, JSON.stringify(arr)) }
  $('saveSetBtn').onclick=()=>{
    const name = prompt('Name for this set:','My Set');
    if(!name) return;
    const id = new URLSearchParams(location.search).get('setId') || ('set_'+Date.now().toString(36));
    const sets = getSets();
    const idx = sets.findIndex(s=>s.id===id);
    const entry = { id, name, updated: Date.now(), map };
    if(idx>=0) sets[idx]=entry; else sets.unshift(entry);
    saveSets(sets);
    alert('Saved! Find it under “My Sets” on the Home page.');
  };

  $('playBtn').onclick=()=>togglePlay();

  // ===== INPUT =====
  addEventListener('contextmenu', e=>e.preventDefault());
  addEventListener('keydown', e=>{
    const k=e.key.toLowerCase();
    if(['w','a','s','d','arrowup','arrowdown','arrowleft','arrowright',' '].includes(k)) e.preventDefault();
    if(['-','=','0'].includes(e.key)) e.preventDefault();
    if(k>='1'&&k<='5') setLayer(Number(k));
    if(k==='g') showGrid=!showGrid;
    if(k==='p') togglePlay();
    if(k==='c'){ brushSolid=!brushSolid; refreshSolidBtn() }
    if(k==='h'){ showSolidOverlay=!showSolidOverlay; refreshColliderVisBtn() }
    if(e.key==='='||e.key==='+') VIEW.zoom=clamp(VIEW.zoom+VIEW.step,VIEW.min,VIEW.max);
    if(e.key==='-'||e.key==='_') VIEW.zoom=clamp(VIEW.zoom-VIEW.step,VIEW.min,VIEW.max);
    if(e.key==='0') VIEW.zoom=VIEW.def;
    keys.add(k);
  }, {capture:true});
  addEventListener('keyup', e=>{ keys.delete(e.key.toLowerCase()) }, {capture:true});

  cvs.addEventListener('mousedown', e=>{
    const pos=screenToWorld(e.offsetX,e.offsetY);
    mouse.down=true; mouse.button=e.button; mouse.tx=-1; mouse.ty=-1;
    if(e.altKey){ const c=getCell(currentLayer-1,pos.tx,pos.ty); if(c){ tileKey=keyByType(c.t)||tileKey; brushSolid=!!c.s; renderPalette(); refreshSolidBtn(); } return; }
    if(e.button===1 || (e.button===0 && keys.has(' '))){ mouse.panning=true; mouse.panStart={x:e.clientX,y:e.clientY}; mouse.camStart={x:camera.x,y:camera.y}; return; }
    handlePaint(pos.tx,pos.ty,e);
  });
  cvs.addEventListener('mousemove', e=>{
    const pos=screenToWorld(e.offsetX,e.offsetY);
    mouse.worldX=pos.x; mouse.worldY=pos.y;
    if(mouse.panning){
      const dx=(e.clientX-mouse.panStart.x)/VIEW.zoom, dy=(e.clientY-mouse.panStart.y)/VIEW.zoom;
      camera.x=clamp(mouse.camStart.x-dx,0,world.w-viewW()); camera.y=clamp(mouse.camStart.y-dy,0,world.h-viewH()); return;
    }
    if(mouse.down && mouse.button!==1 && !(mouse.button===0 && keys.has(' '))) handlePaint(pos.tx,pos.ty,e);
  });
  addEventListener('mouseup', ()=>{ mouse.down=false; mouse.panning=false });

  // ===== HELPERS =====
  function clamp(v,a,b){ return Math.max(a,Math.min(b,v)) }
  function inBounds(tx,ty){ return tx>=0&&ty>=0&&tx<MAP_W&&ty<MAP_H }
  function setCell(l,tx,ty,c){ if(inBounds(tx,ty)) map.layers[l][ty][tx]=c }
  function getCell(l,tx,ty){ return inBounds(tx,ty) ? map.layers[l][ty][tx] : null }
  function anySolidAt(tx,ty){ if(!inBounds(tx,ty)) return false; for(let l=0;l<LAYERS;l++){ if(map.layers[l][ty][tx].s) return true } return false }
  function validType(t){ return Object.values(TILES).includes(t) ? t : TILES.GRASS }
  function keyByType(t){ for(const [k,v] of Object.entries(TILES)) if(v===t) return k; return null }

  function handlePaint(tx,ty,e){
    if(!inBounds(tx,ty)) return;
    if(mouse.tx===tx && mouse.ty===ty && e.type==='mousemove') return;
    mouse.tx=tx; mouse.ty=ty;
    if(e.button===2 || tool==='erase'){ setCell(currentLayer-1,tx,ty,makeTile()); saveAutosaveDebounced(); return; }
    const onlySolid=e.shiftKey, onlyType=e.ctrlKey||e.metaKey;
    const cell=getCell(currentLayer-1,tx,ty) || makeTile();
    const newType=TILES[tileKey], newSolid=brushSolid?1:0;
    let t=cell.t, s=cell.s?1:0;
    if(onlySolid) s=newSolid; else if(onlyType) t=newType; else { t=newType; s=newSolid; }
    setCell(currentLayer-1,tx,ty,makeTile(validType(t),s)); saveAutosaveDebounced();
  }

  function smoothDamp(cur,tgt,vel,smooth,limit,dt){
    smooth=Math.max(.0001,smooth); const om=2/smooth, x=om*dt, exp=1/(1+x+.48*x*x+.235*x*x*x);
    let change=cur-tgt; const orig=tgt; const max=limit*smooth; change=Math.max(-max,Math.min(max,change));
    tgt=cur-change; const temp=(vel+om*change)*dt; let newVel=(vel-om*temp)*exp; let val=tgt+(change+temp)*exp;
    if((orig-cur)*(val-orig)>0){ val=orig; newVel=0 } return {value:val, velocity:newVel};
  }
  function updateCamera(dt){
    const cx=player.x + player.face.x*CAM.lookAhead, cy=player.y + player.face.y*CAM.lookAhead;
    const tx=clamp(cx - viewW()/2,0,Math.max(0,world.w-viewW()));
    const ty=clamp(cy - viewH()/2,0,Math.max(0,world.h-viewH()));
    const sx=smoothDamp(camera.x,tx,camera.vx,CAM.smoothTime,CAM.maxSpeed,dt); camera.x=sx.value; camera.vx=sx.velocity;
    const sy=smoothDamp(camera.y,ty,camera.vy,CAM.smoothTime,CAM.maxSpeed,dt); camera.y=sy.value; camera.vy=sy.velocity;
  }
  function moveAndCollide(dx,dy){
    const r=PLAYER.radius;
    if(dx!==0){ let nx=player.x+dx;
      if(dx>0){ const right=nx+r, tx=Math.floor(right/TILE), top=Math.floor((player.y-r)/TILE), bot=Math.floor((player.y+r-0.001)/TILE);
        for(let ty=top;ty<=bot;ty++){ if(anySolidAt(tx,ty)){ nx=tx*TILE - r - .001; dx=0; break; } } }
      else { const left=nx-r, tx=Math.floor(left/TILE), top=Math.floor((player.y-r)/TILE), bot=Math.floor((player.y+r-0.001)/TILE);
        for(let ty=top;ty<=bot;ty++){ if(anySolidAt(tx,ty)){ nx=(tx+1)*TILE + r + .001; dx=0; break; } } }
      player.x=nx; }
    if(dy!==0){ let ny=player.y+dy;
      if(dy>0){ const bottom=ny+r, ty=Math.floor(bottom/TILE), left=Math.floor((player.x-r)/TILE), right=Math.floor((player.x+r-0.001)/TILE);
        for(let tx=left;tx<=right;tx++){ if(anySolidAt(tx,ty)){ ny=ty*TILE - r - .001; dy=0; break; } } }
      else { const top=ny-r, ty=Math.floor(top/TILE), left=Math.floor((player.x-r)/TILE), right=Math.floor((player.x+r-0.001)/TILE);
        for(let tx=left;tx<=right;tx++){ if(anySolidAt(tx,ty)){ ny=(ty+1)*TILE + r + .001; dy=0; break; } } }
      player.y=ny; }
    const rr=PLAYER.radius+2; player.x=clamp(player.x,rr,world.w-rr); player.y=clamp(player.y,rr,world.h-rr);
  }

  function viewW(){ return (cvs.width/DPR)/VIEW.zoom }
  function viewH(){ return (cvs.height/DPR)/VIEW.zoom }
  function screenToWorld(sx,sy){ const x=camera.x+(sx/DPR)/VIEW.zoom, y=camera.y+(sy/DPR)/VIEW.zoom; return {x,y,tx:Math.floor(x/TILE),ty:Math.floor(y/TILE)} }

  function drawTileType(t,x,y){
    switch(t){
      case TILES.GRASS: ctx.fillStyle=patterns.GRASS; ctx.fillRect(x,y,TILE,TILE); break;
      case TILES.DIRT:  ctx.fillStyle=patterns.DIRT;  ctx.fillRect(x,y,TILE,TILE); break;
      case TILES.PATH:  ctx.fillStyle=patterns.PATH;  ctx.fillRect(x,y,TILE,TILE); break;
      case TILES.SAND:  ctx.fillStyle=patterns.SAND;  ctx.fillRect(x,y,TILE,TILE); break;
      case TILES.WATER: ctx.fillStyle=patterns.WATER; ctx.fillRect(x,y,TILE,TILE); break;
      case TILES.STONE: ctx.fillStyle=patterns.STONE; ctx.fillRect(x,y,TILE,TILE); break;
      case TILES.WALL:
        ctx.fillStyle=COLORS.wallTop;  ctx.fillRect(x,y,TILE,8);
        ctx.fillStyle=COLORS.wallFace; ctx.fillRect(x,y+8,TILE,TILE-8);
        ctx.strokeStyle=COLORS.wallOutline; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(x+0.5,y+0.5); ctx.lineTo(x+TILE-0.5,y+0.5); ctx.stroke();
        ctx.fillStyle=COLORS.wallEdge; ctx.fillRect(x+TILE-4,y+8,4,TILE-8); ctx.fillRect(x,y+TILE-4,TILE,4);
        break;
    }
  }
  function drawSolidOverlay(x,y){ ctx.fillStyle=COLORS.solidFill; ctx.fillRect(x,y,TILE,TILE); ctx.strokeStyle=COLORS.solidStroke; ctx.lineWidth=1.25; ctx.beginPath(); ctx.moveTo(x+4,y+4); ctx.lineTo(x+TILE-4,y+TILE-4); ctx.moveTo(x+TILE-4,y+4); ctx.lineTo(x+4,y+TILE-4); ctx.stroke(); }

  function drawWorld(){
    const vW=viewW(), vH=viewH(), startTX=Math.floor(camera.x/TILE), startTY=Math.floor(camera.y/TILE), endTX=Math.ceil((camera.x+vW)/TILE), endTY=Math.ceil((camera.y+vH)/TILE);
    for(let l=0;l<LAYERS;l++){
      if(!layerUI[l].visible) continue;
      ctx.globalAlpha = (l+1===currentLayer)?1:0.8;
      for(let ty=startTY; ty<endTY; ty++) for(let tx=startTX; tx<endTX; tx++){
        const c=getCell(l,tx,ty); if(!c||c.t===TILES.EMPTY) continue; const x=tx*TILE-camera.x, y=ty*TILE-camera.y;
        drawTileType(c.t,x,y); if(showSolidOverlay && c.s) drawSolidOverlay(x,y);
      }
      ctx.globalAlpha=1;
    }
    if(showGrid){
      ctx.strokeStyle=COLORS.grid; ctx.lineWidth=1;
      for(let ty=startTY; ty<=endTY; ty++){ const y=ty*TILE-camera.y; ctx.beginPath(); ctx.moveTo(startTX*TILE-camera.x,y); ctx.lineTo(endTX*TILE-camera.x,y); ctx.stroke(); }
      for(let tx=startTX; tx<=endTX; tx++){ const x=tx*TILE-camera.x; ctx.beginPath(); ctx.moveTo(x,startTY*TILE-camera.y); ctx.lineTo(x,endTY*TILE-camera.y); ctx.stroke(); }
    }
    if(!playtest){ const tx=Math.floor(mouse.worldX/TILE), ty=Math.floor(mouse.worldY/TILE); if(inBounds(tx,ty)){ const hx=tx*TILE-camera.x, hy=ty*TILE-camera.y; ctx.fillStyle=COLORS.hover; ctx.fillRect(hx,hy,TILE,TILE); } }
  }
  function drawPlayer(){ const px=player.x-camera.x, py=player.y-camera.y, r=PLAYER.radius; ctx.fillStyle=PLAYER.color; ctx.beginPath(); ctx.arc(px,py,r,0,Math.PI*2); ctx.fill(); const a=Math.atan2(player.face.y,player.face.x); ctx.save(); ctx.translate(px,py); ctx.rotate(a); ctx.fillStyle="#1d213f"; ctx.beginPath(); ctx.moveTo(r*.9,0); ctx.lineTo(r*.2,6); ctx.lineTo(r*.2,-6); ctx.closePath(); ctx.fill(); ctx.restore(); ctx.fillStyle="rgba(0,0,0,0.25)"; ctx.beginPath(); ctx.ellipse(px,py+r*.55,r*.9,r*.45,0,0,Math.PI*2); ctx.fill(); }

  // ===== LOOP =====
  let last=performance.now(), fps=0, acc=0, frames=0; const badge=document.getElementById('badge');
  function tick(now){
    const dt=Math.min(.033,(now-last)/1000); last=now;
    acc+=dt; frames++; if(acc>=.5){ fps=Math.round(frames/acc); frames=0; acc=0; badge.textContent=`${fps} fps ${playtest?'• PLAY':'• EDIT'} • zoom ${VIEW.zoom.toFixed(2)}x • L${currentLayer} • Solid:${brushSolid?'On':'Off'}` }
    ctx.setTransform(DPR,0,0,DPR,0,0); ctx.clearRect(0,0,cvs.width/DPR,cvs.height/DPR);
    ctx.save(); ctx.scale(VIEW.zoom,VIEW.zoom);
    if(playtest){
      const ax=(keys.has('d')||keys.has('arrowright')?1:0)-(keys.has('a')||keys.has('arrowleft')?1:0);
      const ay=(keys.has('s')||keys.has('arrowdown')?1:0)-(keys.has('w')||keys.has('arrowup')?1:0);
      let len=Math.hypot(ax,ay), dx=0, dy=0; if(len){ dx=ax/len; dy=ay/len; player.face={x:dx,y:dy} }
      const speed=PLAYER.baseSpeed*(keys.has('shift')?PLAYER.sprintMult:1); moveAndCollide(dx*speed*dt, dy*speed*dt); updateCamera(dt);
    }
    drawWorld(); if(playtest) drawPlayer();
    ctx.restore(); requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // ===== AUTOSAVE =====
  const AUTOKEY='topdown_map_autosave_v4';
  function saveAutosave(force=false){ try{ localStorage.setItem(AUTOKEY, JSON.stringify(map)); if(force) console.log('Autosave loaded') }catch{} }
  let saveTimer=null; function saveAutosaveDebounced(){ clearTimeout(saveTimer); saveTimer=setTimeout(saveAutosave,400) }
  try{ const raw=localStorage.getItem(AUTOKEY); if(raw){ const obj=JSON.parse(raw); if(obj?.layers?.length===LAYERS && obj.meta?.version>=4){ for(let l=0;l<LAYERS;l++) map.layers[l]=obj.layers[l].map(r=>r.map(c=>makeTile(validType(c.t), c.s?1:0))) } } }catch{}

  function togglePlay(){ playtest=!playtest; if(playtest){ camera.x=clamp(player.x-viewW()/2,0,Math.max(0,world.w-viewW())); camera.y=clamp(player.y-viewH()/2,0,Math.max(0,world.h-viewH())); camera.vx=camera.vy=0 } document.getElementById('playBtn').textContent=playtest?'■ Stop':'▶ Playtest' }

  // ===== PARAM LOADER: template|setId|room =====
  const params = new URLSearchParams(location.search);
  const template = params.get('template'); const setId = params.get('setId'); const room = params.get('room');
  if(room){ console.log('Joined room code:', room, '(placeholder — no server)'); }
  if(setId){
    const sets = (function(){ try{ return JSON.parse(localStorage.getItem('gk_sets_v1'))||[] }catch{ return [] }})();
    const s = sets.find(x=>x.id===setId);
    if(s && s.map){
      try{
        if(s.map.meta?.version>=4){ for(let l=0;l<LAYERS;l++) map.layers[l]=s.map.layers[l].map(r=>r.map(c=>makeTile(validType(c.t), c.s?1:0))) }
        else if(s.map.layers){ const WALL=(s.map.meta.tiles&&s.map.meta.tiles.WALL)||2; for(let l=0;l<LAYERS;l++){ map.layers[l]=s.map.layers[l].map(r=>r.map(v=>{const t=Number(v)|0; return makeTile(Object.values(TILES).includes(t)?t:TILES.GRASS, t===WALL?1:0)})) } }
      }catch(e){ console.warn('Failed to load set map; starting blank.', e) }
    }
  } else if(template){ applyTemplate(template) }

  function applyTemplate(key){
    // simple procedural templates
    for(let l=0;l<LAYERS;l++) map.layers[l]=make2D(MAP_W,MAP_H,()=>makeTile());
    if(key==='meadow'){
      fillRect(0,0,MAP_W,MAP_H,(x,y)=>makeTile(TILES.GRASS,0));
      noisePatch(TILES.SAND, 0.12);
      riverHorizontal(~~(MAP_H/2)-2, 4);
    } else if(key==='island'){
      fillRect(0,0,MAP_W,MAP_H,(x,y)=>makeTile(TILES.WATER,0));
      blobbyIsland(MAP_W/2, MAP_H/2, Math.min(MAP_W,MAP_H)/2.2, TILES.SAND, TILES.GRASS);
    } else if(key==='arena'){
      fillRect(0,0,MAP_W,MAP_H,()=>makeTile(TILES.STONE,0));
      // walls as SOLID flags (visual stone)
      frameWalls(2);
    }
    saveAutosave(true);
  }
  function forEachTile(cb){ for(let y=0;y<MAP_H;y++) for(let x=0;x<MAP_W;x++) cb(x,y) }
  function fillRect(x0,y0,w,h,fn){ for(let y=y0;y<y0+h;y++) for(let x=x0;x<x0+w;x++) map.layers[0][y][x]=fn(x,y) }
  function riverHorizontal(yStart, thickness){ for(let y=yStart;y<yStart+thickness;y++) for(let x=0;x<MAP_W;x++) map.layers[0][y][x]=makeTile(TILES.WATER,0) }
  function noisePatch(type, density){ forEachTile((x,y)=>{ if(Math.random()<density) map.layers[0][y][x]=makeTile(type,0) }) }
  function blobbyIsland(cx,cy,r,edgeType,coreType){
    forEachTile((x,y)=>{ const dx=x-cx, dy=y-cy; const d=Math.hypot(dx,dy) + (Math.sin(x*0.7)+Math.cos(y*.6))*0.6;
      if(d<r*0.9) map.layers[0][y][x]=makeTile(coreType,0); else if(d<r*1.02) map.layers[0][y][x]=makeTile(edgeType,0);
    });
  }
  function frameWalls(th){ for(let t=0;t<th;t++){ for(let x=0;x<MAP_W;x++){ map.layers[0][t][x]=makeTile(TILES.STONE,1); map.layers[0][MAP_H-1-t][x]=makeTile(TILES.STONE,1) }
    for(let y=0;y<MAP_H;y++){ map.layers[0][y][t]=makeTile(TILES.STONE,1); map.layers[0][y][MAP_W-1-t]=makeTile(TILES.STONE,1) } } }
})();
</script>
</body>
</html>
