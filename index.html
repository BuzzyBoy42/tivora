<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Top-Down Map Editor — Any Block Can Be Solid</title>
<style>
  :root { --bg:#0f1020; --ink:#e8e9ff; --muted:#a3a9bd; --panel:rgba(22,24,42,.55); --accent:#7c93ff; }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:500 14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Inter,sans-serif}
  canvas{display:block;width:100vw;height:100vh;background:#0d0f1d;image-rendering:pixelated;cursor:crosshair}

  .ui{
    position:fixed;inset:12px auto auto 12px;width:380px;max-height:calc(100dvh - 24px);
    display:grid;gap:10px;padding:12px;border-radius:14px;background:var(--panel);backdrop-filter:blur(10px);
    border:1px solid rgba(124,147,255,.25);box-shadow:0 20px 50px rgba(0,0,0,.35);overflow:auto
  }
  h1{margin:0 0 6px;font-size:15px;color:var(--accent);letter-spacing:.3px}
  .sub{color:var(--muted);margin-top:-4px}
  .row{display:grid;gap:8px}
  .cols{grid-template-columns:repeat(3,1fr)}
  .btn,.chip,.seg button{border:1px solid rgba(255,255,255,.12);background:#11152a;color:var(--ink);padding:8px 10px;border-radius:10px;cursor:pointer}
  .btn:hover,.chip:hover,.seg button:hover{background:#141936}
  .seg{display:flex;gap:6px;flex-wrap:wrap}
  .active{background:#1a2144;border-color:rgba(124,147,255,.45);color:var(--accent)}
  .kbd{background:rgba(255,255,255,.08);padding:2px 6px;border-radius:6px;border:1px solid rgba(255,255,255,.12)}
  .layers{display:grid;gap:6px}
  .layer{display:grid;grid-template-columns:auto 1fr auto;align-items:center;gap:8px;padding:6px 8px;border-radius:10px;background:#0f1430;border:1px solid rgba(255,255,255,.08)}
  .name{font-weight:600}
  .legend{display:flex;gap:8px;flex-wrap:wrap}
  .chip{display:flex;align-items:center;gap:8px}
  .swatch{width:14px;height:14px;border-radius:4px;border:1px solid rgba(255,255,255,.25)}
  .hint{color:var(--muted);font-size:12px}
  .badge{position:fixed;right:12px;bottom:10px;font-variant-numeric:tabular-nums;color:var(--muted);background:rgba(255,255,255,.05);padding:6px 10px;border-radius:8px;border:1px solid rgba(255,255,255,.1)}
  .hidden{display:none}
</style>
</head>
<body>
<canvas id="game"></canvas>

<div class="ui" id="panel">
  <div>
    <h1>Map Editor — 5 Layers</h1>
    <div class="sub">
      Left-click paint • Right-click erase • <span class="kbd">Space</span>+drag pan •
      <span class="kbd">=</span>/<span class="kbd">-</span>/<span class="kbd">0</span> zoom •
      <span class="kbd">1–5</span> layer
    </div>
    <div class="sub">
      <b>Shift</b> = paint <i>solid</i> only • <b>Ctrl</b> = paint <i>type</i> only • <b>Alt+Click</b> = eyedropper
    </div>
  </div>

  <div class="row">
    <div class="legend">
      <button class="chip active" id="tool-paint"><span class="swatch" style="background:linear-gradient(45deg,#232746 50%,#3b4274 0)"></span> Paint</button>
      <button class="chip" id="tool-erase"><span class="swatch" style="background:transparent"></span> Erase</button>
    </div>
  </div>

  <div class="row">
    <div class="legend" id="tilePalette"></div>
    <div class="seg">
      <button class="btn" id="solidBtn">Solid: Off (C)</button>
      <button class="btn" id="colliderVisBtn">Show Colliders: On (H)</button>
    </div>
    <div class="hint">Any tile can be solid (collidable). "Wall" is just a visual type now.</div>
  </div>

  <div class="row">
    <div class="layers" id="layerBtns"></div>
    <div class="hint">Layer 1 = bottom, Layer 5 = top. Visibility toggles affect editor view only.</div>
  </div>

  <div class="row cols">
    <button class="btn" id="clearLayerBtn">Clear Layer</button>
    <button class="btn" id="clearAllBtn">Clear All</button>
    <button class="btn" id="toggleGridBtn">Grid</button>
  </div>

  <div class="row">
    <div class="seg">
      <button class="btn" id="exportBtn">Export JSON</button>
      <button class="btn" id="copyBtn">Copy JSON</button>
      <button class="btn" id="importBtn">Import JSON</button>
      <input class="hidden" type="file" id="fileInput" accept="application/json">
    </div>
    <div class="hint">Autosaves locally every few seconds. Old maps auto-convert (WALL → solid).</div>
  </div>

  <div class="row">
    <div class="seg">
      <button class="btn" id="playBtn">▶ Playtest</button>
      <span class="hint">WASD/Arrows • Shift to sprint. Smooth follow camera.</span>
    </div>
  </div>
</div>

<div class="badge" id="badge">0 fps</div>

<script>
(() => {
  // ===== CONFIG =====
  const TILE = 48;
  const MAP_W = 60, MAP_H = 34;
  const LAYERS = 5;                      // 1..5 (1 bottom)
  const VIEW = { zoom: 1.8, min: 0.9, max: 3.5, step: 0.1, def: 1.8 };
  const PLAYER = { radius: 14, baseSpeed: 170, sprintMult: 1.45, color: "#ffd86b" };

  // Visual tile types (collision is separate!)
  const TILES = {
    EMPTY: 0,
    GRASS: 1,
    WALL:  2, // still a visual variant; no inherent collision
    DIRT:  3,
    PATH:  4,
    SAND:  5,
    WATER: 6,
    STONE: 7
  };

  // Palette entries
  const TILE_PALETTE = [
    { key: "GRASS", label: "Grass",  color: "#2f7d3b" },
    { key: "DIRT",  label: "Dirt",   color: "#6b4a2b" },
    { key: "PATH",  label: "Path",   color: "#b99a66" },
    { key: "SAND",  label: "Sand",   color: "#d8c27a" },
    { key: "WATER", label: "Water",  color: "#2d6bba" },
    { key: "STONE", label: "Stone",  color: "#7a808c" },
    { key: "WALL",  label: "Wall (visual)", color: "#3b4274" }
  ];

  const COLORS = {
    grid:"rgba(255,255,255,0.06)",
    hover:"rgba(124,147,255,0.22)",
    // wall face (visual)
    wallTop:"#4a579a", wallFace:"#2a2f55", wallOutline:"#a9b1ff", wallEdge:"rgba(0,0,0,0.40)",
    // collider overlay
    solidStroke:"rgba(255,119,119,0.9)",
    solidFill:"rgba(255,80,80,0.12)"
  };

  // ===== STATE =====
  let DPR = 1;
  const cvs = document.getElementById("game");
  const ctx = cvs.getContext("2d");
  function resize(){DPR=Math.max(1,Math.min(2,window.devicePixelRatio||1));cvs.width=Math.floor(innerWidth*DPR);cvs.height=Math.floor(innerHeight*DPR);ctx.setTransform(DPR,0,0,DPR,0,0)}
  addEventListener("resize", resize, {passive:true}); resize();

  // Map data structure: layers[l][y][x] -> { t: <tileType>, s: 0|1 }  (type + solid)
  const makeTile = (t=TILES.EMPTY,s=0)=>({t,s});
  const make2D = (w,h,cellFn)=>Array.from({length:h},(_,y)=>Array.from({length:w},(_,x)=>cellFn(x,y)));
  const map = {
    layers: Array.from({length:LAYERS},()=>make2D(MAP_W,MAP_H,()=>makeTile())),
    meta: { w:MAP_W, h:MAP_H, tile:TILE, tiles:TILES, version:4 } // <-- new version
  };
  const world = { w: MAP_W * TILE, h: MAP_H * TILE };

  const camera = { x:0, y:0, vx:0, vy:0 };
  const CAM = { smoothTime:0.14, maxSpeed:6000, lookAhead:38 };

  const player = { x:TILE*3, y:TILE*3, face:{x:1,y:0} };
  let playtest=false, showGrid=true, showSolidOverlay=true, currentLayer=1, tool="paint", tileKey="GRASS", brushSolid=false;

  const keys = new Set();
  const mouse = { down:false, button:0, panning:false, panStart:{x:0,y:0}, camStart:{x:0,y:0}, worldX:0, worldY:0, tx:-1, ty:-1 };

  // ===== PATTERN CACHE =====
  const patterns = {};
  function makePattern(w, h, drawFn) {
    const c = document.createElement("canvas");
    c.width = w; c.height = h;
    const k = c.getContext("2d");
    drawFn(k, w, h);
    return k.createPattern(c, "repeat");
  }
  function initPatterns() {
    // GRASS
    patterns.GRASS = makePattern(16,16,(k,w,h)=>{
      k.fillStyle = "#244e2c"; k.fillRect(0,0,w,h);
      k.fillStyle = "#2e6a37"; for(let y=0;y<h;y+=8){for(let x=0;x<w;x+=8){k.fillRect(x,y,8,8);}}
      k.strokeStyle = "rgba(255,255,255,0.06)"; k.lineWidth=1;
      for(let i=0;i<6;i++){ const x=Math.random()*w; const y=Math.random()*h; k.beginPath(); k.moveTo(x,y); k.lineTo(x+1,y-2); k.stroke(); }
    });
    // DIRT
    patterns.DIRT = makePattern(16,16,(k,w,h)=>{
      k.fillStyle = "#5f3f27"; k.fillRect(0,0,w,h);
      k.fillStyle = "#6b4a2b";
      for(let i=0;i<18;i++){ k.globalAlpha = 0.15 + Math.random()*0.25; k.beginPath(); k.arc(Math.random()*w, Math.random()*h, Math.random()*1.5+0.5, 0, Math.PI*2); k.fill(); }
      k.globalAlpha = 1;
    });
    // PATH
    patterns.PATH = makePattern(16,16,(k,w,h)=>{
      k.fillStyle = "#b99a66"; k.fillRect(0,0,w,h);
      k.strokeStyle = "rgba(0,0,0,0.10)"; k.lineWidth=1;
      for(let i=-h;i<w+h;i+=5){ k.beginPath(); k.moveTo(i,0); k.lineTo(i-h,h); k.stroke(); }
    });
    // SAND
    patterns.SAND = makePattern(16,16,(k,w,h)=>{
      k.fillStyle = "#d8c27a"; k.fillRect(0,0,w,h);
      k.fillStyle = "rgba(0,0,0,0.10)"; for(let i=0;i<20;i++){ k.fillRect(Math.random()*w, Math.random()*h, 1, 1); }
      k.fillStyle = "rgba(255,255,255,0.12)"; for(let i=0;i<12;i++){ k.fillRect(Math.random()*w, Math.random()*h, 1, 1); }
    });
    // WATER
    patterns.WATER = makePattern(32,32,(k,w,h)=>{
      const grad = k.createLinearGradient(0,0,0,h);
      grad.addColorStop(0,"#1f4b85"); grad.addColorStop(1,"#15365f");
      k.fillStyle = grad; k.fillRect(0,0,w,h);
      k.strokeStyle = "rgba(255,255,255,0.15)"; k.lineWidth=1;
      for(let y=4; y<h; y+=8){ k.beginPath(); for(let x=0; x<=w; x+=4){ k.lineTo(x, y + Math.sin((x+y)*0.25)*1.2); } k.stroke(); }
    });
    // STONE
    patterns.STONE = makePattern(16,16,(k,w,h)=>{
      const g = k.createLinearGradient(0,0,0,h); g.addColorStop(0,"#757b86"); g.addColorStop(1,"#666c77");
      k.fillStyle=g; k.fillRect(0,0,w,h);
      k.strokeStyle="rgba(0,0,0,0.22)"; k.lineWidth=1; k.beginPath();
      k.moveTo(0,0);k.lineTo(w,0);k.moveTo(0,h);k.lineTo(w,h);k.moveTo(0,0);k.lineTo(0,h);k.moveTo(w,0);k.lineTo(w,h);
      k.stroke();
      k.fillStyle="rgba(255,255,255,0.08)"; k.fillRect(4,8,1,1);
      k.fillStyle="rgba(0,0,0,0.15)"; k.fillRect(12,6,1,1);
    });
  }
  initPatterns();

  // ===== UI =====
  const q = (id)=>document.getElementById(id);

  // Tools
  const toolPaint=q("tool-paint"), toolErase=q("tool-erase");
  function setTool(t){ tool=t; toolPaint.classList.toggle("active",tool==="paint"); toolErase.classList.toggle("active",tool==="erase"); }
  toolPaint.onclick=()=>setTool("paint"); toolErase.onclick=()=>setTool("erase"); setTool("paint");

  // Tile palette
  const tilePalette = q("tilePalette");
  function renderPalette() {
    tilePalette.innerHTML = "";
    TILE_PALETTE.forEach(item => {
      const btn = document.createElement("button");
      btn.className = "chip";
      btn.dataset.tile = item.key;
      btn.innerHTML = `<span class="swatch" style="background:${item.color}"></span>${item.label}`;
      if (item.key === tileKey) btn.classList.add("active");
      btn.onclick = () => { tileKey = item.key; [...tilePalette.children].forEach(c=>c.classList.remove("active")); btn.classList.add("active"); };
      tilePalette.appendChild(btn);
    });
  }
  renderPalette();

  // Solid brush toggle + overlay toggle
  const solidBtn = q("solidBtn");
  const colliderVisBtn = q("colliderVisBtn");
  function refreshSolidBtn(){ solidBtn.textContent = `Solid: ${brushSolid ? "On" : "Off"} (C)`; solidBtn.classList.toggle("active", brushSolid); }
  function refreshColliderVisBtn(){ colliderVisBtn.textContent = `Show Colliders: ${showSolidOverlay ? "On" : "Off"} (H)`; colliderVisBtn.classList.toggle("active", showSolidOverlay); }
  solidBtn.onclick = ()=>{ brushSolid=!brushSolid; refreshSolidBtn(); };
  colliderVisBtn.onclick = ()=>{ showSolidOverlay=!showSolidOverlay; refreshColliderVisBtn(); };
  refreshSolidBtn(); refreshColliderVisBtn();

  // Layers list
  const layerBtns = q("layerBtns"), layerUI=[];
  for (let i=1;i<=LAYERS;i++){
    const row=document.createElement("div");row.className="layer";
    const eye=document.createElement("input");eye.type="checkbox";eye.checked=true;eye.title="Toggle layer visibility";
    const name=document.createElement("div");name.className="name";name.textContent=`Layer ${i}${i===1?' (bottom)':''}${i===5?' (top)':''}`;
    const pick=document.createElement("button");pick.className="btn";pick.textContent="Select";pick.onclick=()=>setLayer(i);
    eye.onchange=()=>{layerUI[i-1].visible=eye.checked};
    row.append(eye,name,pick); layerBtns.appendChild(row); layerUI.push({visible:true,eye,pick});
  }
  function setLayer(n){ currentLayer=n; layerUI.forEach((L,idx)=>L.pick.classList.toggle("active",idx===n-1)); }
  setLayer(1);

  // Buttons
  q("clearLayerBtn").onclick=()=>{map.layers[currentLayer-1]=make2D(MAP_W,MAP_H,()=>makeTile());saveAutosave()};
  q("clearAllBtn").onclick=()=>{for(let i=0;i<LAYERS;i++)map.layers[i]=make2D(MAP_W,MAP_H,()=>makeTile());saveAutosave()};
  q("toggleGridBtn").onclick=()=>{showGrid=!showGrid};
  q("exportBtn").onclick=()=>download("map.json", JSON.stringify(map));
  q("copyBtn").onclick=async()=>{try{await navigator.clipboard.writeText(JSON.stringify(map));alert("Copied JSON")}catch{alert("Clipboard blocked; use Export JSON")}};
  q("importBtn").onclick=()=>q("fileInput").click();
  q("fileInput").addEventListener("change",async(e)=>{const f=e.target.files[0];if(!f)return;try{
      const t=await f.text();const o=JSON.parse(t);
      if(!o.layers||!o.meta) throw new Error("Invalid file");
      if(o.meta.w!==MAP_W||o.meta.h!==MAP_H||o.meta.tile!==TILE) throw new Error("Size mismatch");
      // v4 format: objects {t,s}
      if(o.meta.version>=4){
        for(let l=0;l<LAYERS;l++){
          map.layers[l]=o.layers[l].map(row=>row.map(cell=>{
            if (typeof cell==="object" && cell!==null && "t" in cell && "s" in cell) {
              return makeTile(validType(cell.t), cell.s?1:0);
            } else { return makeTile(); }
          }));
        }
      } else {
        // v2/v3 legacy: ints; WALL (2) meant solid
        const oldTiles = o.meta.tiles || TILES;
        const WALL_CODE = oldTiles.WALL ?? 2;
        for(let l=0;l<LAYERS;l++){
          map.layers[l]=o.layers[l].map(row=>row.map(v=>{
            const tcode = Number(v)|0;
            if (!Number.isFinite(tcode)) return makeTile();
            const isWall = (tcode===WALL_CODE);
            // keep same visual type if possible
            const mappedType = Object.values(TILES).includes(tcode) ? tcode : TILES.GRASS;
            return makeTile(mappedType, isWall?1:0);
          }));
        }
      }
      saveAutosave(true);
    }catch(err){alert("Import failed: "+err.message)}finally{e.target.value=""}});

  q("playBtn").onclick=()=>togglePlay();

  // ===== INPUT =====
  addEventListener("contextmenu", e=>e.preventDefault());
  addEventListener("keydown", (e)=>{
    const k=e.key.toLowerCase();
    if(["w","a","s","d","arrowup","arrowdown","arrowleft","arrowright"," "].includes(k)) e.preventDefault();
    if(["-","=","0"].includes(e.key)) e.preventDefault();
    if(k>="1"&&k<="5") setLayer(Number(k));
    if(k==="g") showGrid=!showGrid;
    if(k==="p") togglePlay();
    if(k==="c"){ brushSolid=!brushSolid; refreshSolidBtn(); }
    if(k==="h"){ showSolidOverlay=!showSolidOverlay; refreshColliderVisBtn(); }

    // zoom
    if(e.key==="="||e.key==="+") VIEW.zoom=clamp(VIEW.zoom+VIEW.step,VIEW.min,VIEW.max);
    if(e.key==="-"||e.key==="_") VIEW.zoom=clamp(VIEW.zoom-VIEW.step,VIEW.min,VIEW.max);
    if(e.key==="0") VIEW.zoom=VIEW.def;

    keys.add(k);
  }, {capture:true});
  addEventListener("keyup",(e)=>{keys.delete(e.key.toLowerCase())},{capture:true});

  cvs.addEventListener("mousedown",(e)=>{
    const pos=screenToWorld(e.offsetX,e.offsetY);
    mouse.down=true;mouse.button=e.button;mouse.tx=-1;mouse.ty=-1;

    // eyedropper
    if (e.altKey){
      const cell = getCell(currentLayer-1, pos.tx, pos.ty);
      if (cell){ tileKey = keyByType(cell.t) || tileKey; brushSolid = !!cell.s; renderPalette(); refreshSolidBtn(); }
      return;
    }

    // pan if middle or space+left
    if(e.button===1 || (e.button===0 && keys.has(" "))){
      mouse.panning=true;mouse.panStart={x:e.clientX,y:e.clientY};mouse.camStart={x:camera.x,y:camera.y};return;
    }
    handlePaint(pos.tx,pos.ty,e);
  });
  cvs.addEventListener("mousemove",(e)=>{
    const pos=screenToWorld(e.offsetX,e.offsetY);
    mouse.worldX=pos.x; mouse.worldY=pos.y;

    if(mouse.panning){
      const dx=(e.clientX-mouse.panStart.x)/VIEW.zoom;
      const dy=(e.clientY-mouse.panStart.y)/VIEW.zoom;
      camera.x=clamp(mouse.camStart.x-dx,0,world.w-viewW());
      camera.y=clamp(mouse.camStart.y-dy,0,world.h-viewH());
      return;
    }

    if(mouse.down && mouse.button!==1 && !(mouse.button===0 && keys.has(" "))){
      handlePaint(pos.tx,pos.ty,e);
    }
  });
  addEventListener("mouseup",()=>{mouse.down=false;mouse.panning=false});

  // ===== HELPERS =====
  function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
  function inBounds(tx,ty){return tx>=0&&ty>=0&&tx<MAP_W&&ty<MAP_H}
  function setCell(layer,tx,ty,cell){ if(inBounds(tx,ty)) map.layers[layer][ty][tx] = cell }
  function getCell(layer,tx,ty){ return inBounds(tx,ty) ? map.layers[layer][ty][tx] : null }
  function anySolidAt(tx,ty){ if(!inBounds(tx,ty)) return false; for(let l=0;l<LAYERS;l++){ if(map.layers[l][ty][tx].s) return true } return false }
  function validType(t){ return Object.values(TILES).includes(t) ? t : TILES.GRASS }
  function keyByType(t){ for(const [k,v] of Object.entries(TILES)){ if(v===t) return k } return null }

  function handlePaint(tx,ty,e){
    if(!inBounds(tx,ty)) return;
    if(mouse.tx===tx && mouse.ty===ty && e.type==="mousemove") return; // skip repeats while dragging
    mouse.tx=tx; mouse.ty=ty;

    // erase
    if(e.button===2 || tool==="erase"){ setCell(currentLayer-1,tx,ty,makeTile()); saveAutosaveDebounced(); return; }

    // modifiers
    const onlySolid = e.shiftKey;
    const onlyType  = e.ctrlKey || e.metaKey;

    const cell = getCell(currentLayer-1,tx,ty);
    const newType = TILES[tileKey];
    const newSolid = brushSolid ? 1 : 0;

    let t = cell ? cell.t : TILES.EMPTY;
    let s = cell ? (cell.s?1:0) : 0;

    if (onlySolid) { s = newSolid; }
    else if (onlyType) { t = newType; }
    else { t = newType; s = newSolid; }

    setCell(currentLayer-1,tx,ty, makeTile(validType(t), s));
    saveAutosaveDebounced();
  }

  // ===== CAMERA =====
  function smoothDamp(current,target,velocity,smoothTime,maxSpeed,dt){
    smoothTime=Math.max(0.0001,smoothTime);
    const omega=2/smoothTime, x=omega*dt, exp=1/(1+x+0.48*x*x+0.235*x*x*x);
    let change=current-target; const originalTo=target;
    const maxChange=maxSpeed*smoothTime;
    if(change> maxChange) change= maxChange;
    if(change<-maxChange) change=-maxChange;
    target=current-change;
    const temp=(velocity+omega*change)*dt;
    let newVel=(velocity-omega*temp)*exp;
    let newVal=target+(change+temp)*exp;
    if((originalTo-current)*(newVal-originalTo)>0){newVal=originalTo;newVel=0}
    return {value:newVal, velocity:newVel};
  }
  function updateCamera(dt){
    const centerX = player.x + player.face.x * CAM.lookAhead;
    const centerY = player.y + player.face.y * CAM.lookAhead;
    const targetX = clamp(centerX - viewW()/2, 0, Math.max(0, world.w - viewW()));
    const targetY = clamp(centerY - viewH()/2, 0, Math.max(0, world.h - viewH()));
    const sx = smoothDamp(camera.x, targetX, camera.vx, CAM.smoothTime, CAM.maxSpeed, dt);
    camera.x = sx.value; camera.vx = sx.velocity;
    const sy = smoothDamp(camera.y, targetY, camera.vy, CAM.smoothTime, CAM.maxSpeed, dt);
    camera.y = sy.value; camera.vy = sy.velocity;
  }

  // ===== COLLISION (uses per-tile .s) =====
  function moveAndCollide(dx,dy){
    const r = PLAYER.radius;
    // X
    if(dx!==0){
      let nx=player.x+dx;
      if(dx>0){
        const right=nx+r; const tx=Math.floor(right/TILE);
        const top=Math.floor((player.y-r)/TILE);
        const bot=Math.floor((player.y+r-0.001)/TILE);
        for(let ty=top;ty<=bot;ty++){
          if(anySolidAt(tx,ty)){ nx=tx*TILE - r - 0.001; dx=0; break; }
        }
      } else {
        const left=nx-r; const tx=Math.floor(left/TILE);
        const top=Math.floor((player.y-r)/TILE);
        const bot=Math.floor((player.y+r-0.001)/TILE);
        for(let ty=top;ty<=bot;ty++){
          if(anySolidAt(tx,ty)){ nx=(tx+1)*TILE + r + 0.001; dx=0; break; }
        }
      }
      player.x=nx;
    }
    // Y
    if(dy!==0){
      let ny=player.y+dy;
      if(dy>0){
        const bottom=ny+r; const ty=Math.floor(bottom/TILE);
        const left=Math.floor((player.x-r)/TILE);
        const right=Math.floor((player.x+r-0.001)/TILE);
        for(let tx=left;tx<=right;tx++){
          if(anySolidAt(tx,ty)){ ny=ty*TILE - r - 0.001; dy=0; break; }
        }
      } else {
        const top=ny-r; const ty=Math.floor(top/TILE);
        const left=Math.floor((player.x-r)/TILE);
        const right=Math.floor((player.x+r-0.001)/TILE);
        for(let tx=left;tx<=right;tx++){
          if(anySolidAt(tx,ty)){ ny=(ty+1)*TILE + r + 0.001; dy=0; break; }
        }
      }
      player.y=ny;
    }
    // bounds
    const rr=PLAYER.radius+2;
    player.x=clamp(player.x, rr, world.w-rr);
    player.y=clamp(player.y, rr, world.h-rr);
  }

  // ===== RENDER =====
  function viewW(){ return (cvs.width/DPR)/VIEW.zoom }
  function viewH(){ return (cvs.height/DPR)/VIEW.zoom }

  function screenToWorld(sx,sy){
    const x = camera.x + (sx/DPR)/VIEW.zoom;
    const y = camera.y + (sy/DPR)/VIEW.zoom;
    return { x, y, tx:Math.floor(x/TILE), ty:Math.floor(y/TILE) };
  }

  function drawTileType(t, x, y){
    switch(t){
      case TILES.GRASS: ctx.fillStyle = patterns.GRASS; ctx.fillRect(x,y,TILE,TILE); break;
      case TILES.DIRT:  ctx.fillStyle = patterns.DIRT;  ctx.fillRect(x,y,TILE,TILE); break;
      case TILES.PATH:  ctx.fillStyle = patterns.PATH;  ctx.fillRect(x,y,TILE,TILE); break;
      case TILES.SAND:  ctx.fillStyle = patterns.SAND;  ctx.fillRect(x,y,TILE,TILE); break;
      case TILES.WATER: ctx.fillStyle = patterns.WATER; ctx.fillRect(x,y,TILE,TILE); break;
      case TILES.STONE: ctx.fillStyle = patterns.STONE; ctx.fillRect(x,y,TILE,TILE); break;
      case TILES.WALL:
        // visual "blocky" wall look (no inherent collision)
        ctx.fillStyle = COLORS.wallTop;  ctx.fillRect(x,y,TILE,8);
        ctx.fillStyle = COLORS.wallFace; ctx.fillRect(x,y+8,TILE,TILE-8);
        ctx.strokeStyle = COLORS.wallOutline; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(x+0.5,y+0.5); ctx.lineTo(x+TILE-0.5,y+0.5); ctx.stroke();
        ctx.fillStyle = COLORS.wallEdge;
        ctx.fillRect(x + TILE - 4, y + 8, 4, TILE - 8);
        ctx.fillRect(x, y + TILE - 4, TILE, 4);
        break;
    }
  }

  function drawSolidOverlay(x,y){
    // subtle fill + cross
    ctx.fillStyle = COLORS.solidFill; ctx.fillRect(x,y,TILE,TILE);
    ctx.strokeStyle = COLORS.solidStroke; ctx.lineWidth = 1.25;
    ctx.beginPath(); ctx.moveTo(x+4,y+4); ctx.lineTo(x+TILE-4,y+TILE-4);
    ctx.moveTo(x+TILE-4,y+4); ctx.lineTo(x+4,y+TILE-4); ctx.stroke();
  }

  function drawWorld(){
    const vW=viewW(), vH=viewH();
    const startTX=Math.floor(camera.x/TILE), startTY=Math.floor(camera.y/TILE);
    const endTX=Math.ceil((camera.x+vW)/TILE), endTY=Math.ceil((camera.y+vH)/TILE);

    // layers bottom->top
    for(let l=0;l<LAYERS;l++){
      if(!layerUI[l].visible) continue;
      const alpha = (l+1===currentLayer)?1:0.8;
      ctx.globalAlpha = alpha;

      for(let ty=startTY; ty<endTY; ty++){
        for(let tx=startTX; tx<endTX; tx++){
          const cell = getCell(l,tx,ty);
          if(!cell || cell.t===TILES.EMPTY) continue;
          const x=tx*TILE - camera.x, y=ty*TILE - camera.y;
          drawTileType(cell.t, x, y);
          if (showSolidOverlay && cell.s) drawSolidOverlay(x,y);
        }
      }
      ctx.globalAlpha=1;
    }

    // grid
    if(showGrid){
      ctx.strokeStyle=COLORS.grid; ctx.lineWidth=1;
      for(let ty=startTY; ty<=endTY; ty++){
        const y=ty*TILE - camera.y;
        ctx.beginPath(); ctx.moveTo(startTX*TILE - camera.x, y); ctx.lineTo(endTX*TILE - camera.x, y); ctx.stroke();
      }
      for(let tx=startTX; tx<=endTX; tx++){
        const x=tx*TILE - camera.x;
        ctx.beginPath(); ctx.moveTo(x, startTY*TILE - camera.y); ctx.lineTo(x, endTY*TILE - camera.y); ctx.stroke();
      }
    }

    // hover (edit mode only)
    if(!playtest){
      const tx = Math.floor(mouse.worldX / TILE), ty = Math.floor(mouse.worldY / TILE);
      if(inBounds(tx,ty)){
        const hx=tx*TILE - camera.x, hy=ty*TILE - camera.y;
        ctx.fillStyle = COLORS.hover; ctx.fillRect(hx,hy,TILE,TILE);
      }
    }
  }

  function drawPlayer(){
    const px=player.x - camera.x, py=player.y - camera.y, r=PLAYER.radius;
    ctx.fillStyle=PLAYER.color; ctx.beginPath(); ctx.arc(px,py,r,0,Math.PI*2); ctx.fill();
    const ang=Math.atan2(player.face.y,player.face.x);
    ctx.save(); ctx.translate(px,py); ctx.rotate(ang);
    ctx.fillStyle="#1d213f"; ctx.beginPath(); ctx.moveTo(r*0.9,0); ctx.lineTo(r*0.2,6); ctx.lineTo(r*0.2,-6); ctx.closePath(); ctx.fill();
    ctx.restore();
    ctx.fillStyle="rgba(0,0,0,0.25)"; ctx.beginPath(); ctx.ellipse(px,py+r*.55,r*.9,r*.45,0,0,Math.PI*2); ctx.fill();
  }

  // ===== LOOP =====
  let last=performance.now(), fps=0, acc=0, frames=0;
  const badge=q("badge");
  function tick(now){
    const dt=Math.min(0.033,(now-last)/1000); last=now;

    // fps
    acc+=dt; frames++;
    if(acc>=0.5){ fps=Math.round(frames/acc); frames=0; acc=0; badge.textContent=`${fps} fps ${playtest?"• PLAY":"• EDIT"} • zoom ${VIEW.zoom.toFixed(2)}x • L${currentLayer} • Solid:${brushSolid?"On":"Off"}` }

    // clear
    ctx.setTransform(DPR,0,0,DPR,0,0);
    ctx.clearRect(0,0,cvs.width/DPR,cvs.height/DPR);

    // zoom scope
    ctx.save(); ctx.scale(VIEW.zoom,VIEW.zoom);

    if(playtest){
      const ax = (keys.has("d")||keys.has("arrowright")?1:0) - (keys.has("a")||keys.has("arrowleft")?1:0);
      const ay = (keys.has("s")||keys.has("arrowdown")?1:0) - (keys.has("w")||keys.has("arrowup")?1:0);
      let len=Math.hypot(ax,ay); let dx=0,dy=0;
      if(len){ dx=ax/len; dy=ay/len; player.face={x:dx,y:dy}; }
      const speed=PLAYER.baseSpeed*(keys.has("shift")?PLAYER.sprintMult:1);
      moveAndCollide(dx*speed*dt, dy*speed*dt);
      updateCamera(dt);
    }

    drawWorld();
    if(playtest) drawPlayer();

    ctx.restore();
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // ===== AUTOSAVE =====
  const AUTOKEY="topdown_map_autosave_v4";
  function saveAutosave(force=false){ try{localStorage.setItem(AUTOKEY,JSON.stringify(map)); if(force) console.log("Autosave loaded")}catch{} }
  let saveTimer=null; function saveAutosaveDebounced(){ clearTimeout(saveTimer); saveTimer=setTimeout(saveAutosave,400) }
  try{
    const raw=localStorage.getItem(AUTOKEY);
    if(raw){
      const obj=JSON.parse(raw);
      if(obj?.layers?.length===LAYERS && obj.meta?.version>=4){
        for(let l=0;l<LAYERS;l++) map.layers[l]=obj.layers[l].map(row=>row.map(c=>makeTile(validType(c.t), c.s?1:0)));
      }
    }
  }catch{}

  // ===== MISC =====
  function togglePlay(){
    playtest=!playtest;
    if(playtest){
      camera.x = clamp(player.x - viewW()/2, 0, Math.max(0,world.w - viewW()));
      camera.y = clamp(player.y - viewH()/2, 0, Math.max(0,world.h - viewH()));
      camera.vx=camera.vy=0;
    }
    q("playBtn").textContent = playtest ? "■ Stop" : "▶ Playtest";
  }
  function viewW(){ return (cvs.width/DPR)/VIEW.zoom }
  function viewH(){ return (cvs.height/DPR)/VIEW.zoom }
  function download(name,text){const blob=new Blob([text],{type:"application/json"});const url=URL.createObjectURL(blob);const a=document.createElement("a");a.href=url;a.download=name;a.click();URL.revokeObjectURL(url)}
})();
</script>
</body>
</html>
